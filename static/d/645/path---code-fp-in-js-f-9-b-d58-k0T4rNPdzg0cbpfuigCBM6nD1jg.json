{"data":{"site":{"siteMetadata":{"title":"JλO","author":"Jean-Louis Leysens"}},"markdownRemark":{"id":"6527f22e-0093-5aaf-aa62-ae21b0e3a6af","excerpt":"I enjoy the teachings and precepts of Functional Programming (FP). I enjoy the\nsimplicity of it. It tends to force you to think of one thing at a time. A\nquote…","html":"<p>I enjoy the teachings and precepts of Functional Programming (FP). I enjoy the\nsimplicity of it. It tends to force you to think of one thing at a time. A\nquote that unlocked the power of FP for me is by Alan J. Perlis, as stated in\nClojure’s rationale<sup>1</sup>:</p>\n<blockquote>\n<p>It is better to have 100 functions operate on one data structure than to have\n10 functions operate on 10 data structures.</p>\n</blockquote>\n<p>This idea, for me, shook the world of Object Oriented Programming (OOP). OOP\nwas not rendered without use, but there is certainly something to these\ncomposable units (functions) that understand a shared interface. Interfaces\nlike arrays or lists. These are extremely simple data structures that know\nnothing about your business logic. When we start creating our own functions\nthat operate on arrays and return arrays we quickly gain the ability to express\ndifferent sequences of higher-level <em>operations</em> instead of higher level\n<em>things</em>. See Doug McIlroy’s solution to the problem of finding the frequency\nof different words in a text file<sup>2</sup>.</p>\n<p>To top it off all of this is possible in JS - as in many other languages. What\nmakes it even more pleasant to write in JS is that functions are first-class\nvalues in the same way that objects or numbers are. This means we can write\nfunctions that take functions as arguments — a pattern that is used\nextensively in many applications to solve different problems.</p>\n<p>Taking the teachings of FP a step further we can create law-abiding functions.\nThis is a more extreme version<sup>3</sup> of the idea I stated earlier about shared\ninterfaces<sup>4</sup>. These laws mean that we can reason about the flow of\nour functions in a way that is analagous to mathematic formlae. This also leans\ninto thinking about our functions a type level; give me a number (a type) and I\nwill return a string (another type). I will leave further investigations into category\ntheory to the reader for now as it is beyond the scope of this article (enjoy\npuzzle solving instead of problem solving!).</p>\n<p>At this point I would emphasise that all of the above is why we should almost\ncertainly choose for FP in JS. Why choose complexity (or complectedness) when\nsimplicity is is not only feasible but desirable? This is something FP can\noffer. What is more, there are theoretical or academic aspects to what I have\nmentioned but an enormous amount of practical usefulness too. JS libraries like\n<a href=\"https://lodash.com/\">lodash</a><sup>5</sup> and <a href=\"https://ramdajs.com/\">ramda</a> have\ndemonstrated enormous practical usefulness when creating applications.</p>\n<h3>Notes</h3>\n<ol>\n<li>Listed as one of the points\n<a href=\"https://clojure.org/about/rationale#_object_orientation_is_overrated\">here</a>.</li>\n<li>See <a href=\"https://youtu.be/AkYDsiRVqno?t=875\">this</a> section of a talk by Stefan\nTilkov.</li>\n<li>Today, at time of writing, I would argue pathologically extreme.</li>\n<li>See a library like <a href=\"https://github.com/gcanti/fp-ts\">fp-ts</a>.</li>\n<li>Please do not add this entire library as a dependency in new projects. There\nare many security vulnerabilities that come with it and much of it’s\nfunctionality has since been made available through JS natively.</li>\n</ol>","frontmatter":{"title":"(Don't) write FP in JS","date":"March 21, 2020"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"code","slug":"/code/fp-in-js/","previous":{"fields":{"slug":"/code/elastic-and-zdog/"},"frontmatter":{"title":"Elastic and Zdog"}},"next":{"fields":{"slug":"/code/errors/"},"frontmatter":{"title":"Errors"}}}}