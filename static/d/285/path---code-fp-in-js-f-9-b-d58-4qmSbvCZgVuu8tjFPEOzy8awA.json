{"data":{"site":{"siteMetadata":{"title":"JλO","author":"Jean-Louis Leysens"}},"markdownRemark":{"id":"6527f22e-0093-5aaf-aa62-ae21b0e3a6af","excerpt":"Write FP in JSI enjoy the teachings and precepts of Functional Programming (FP). I enjoy the\nsimplicity of it. It tends to force you to think of one thing at a…","html":"<h2>Write FP in JS</h2>\n<p>I enjoy the teachings and precepts of Functional Programming (FP). I enjoy the\nsimplicity of it. It tends to force you to think of one thing at a time. A\nquote that unlocked the power of FP for me is by Alan J. Perlis, as stated in\nClojure’s rationale<sup>1</sup>:</p>\n<blockquote>\n<p>It is better to have 100 functions operate on one data structure than to have\n10 functions operate on 10 data structures.</p>\n</blockquote>\n<p>This idea, for me, shook the world of Object Oriented Programming (OOP). OOP\nwas not rendered without use, but there is certainly something to these\ncomposable units (functions) that understand a shared interface. Something that\nmakes me hesitate to reach for object inheritance patterns and writing my own\nAPIs. Interfaces like arrays or lists. These are extremely simple data\nstructures that know nothing about your business logic. When we start creating\nour own functions that operate on arrays and return arrays we quickly gain the\nability to express different sequences of higher-level <em>operations</em> instead of\nhigher level <em>things</em>. See Doug McIlroy’s solution to the problem of finding\nthe frequency of different words in a text file<sup>2</sup>.</p>\n<p>All of this is possible in JS - as in many other languages. What\nmakes it even more pleasant to write in JS is that functions are first-class\nvalues in the same way that objects or numbers are. This means we can write\nfunctions that take functions as arguments — a pattern that is used\nextensively in many applications to solve different problems.</p>\n<p>Taking the teachings of FP a step further we can create law-abiding functions.\nThis is a more extreme version<sup>3</sup> of the idea I stated earlier about shared\ninterfaces<sup>4</sup>. These laws mean that we can reason about the flow of\nour functions in a way that is analagous to mathematic formlae. This also leans\ninto thinking about our functions a type level; give me a number (a type) and I\nwill return a string (another type). I will leave further investigations into category\ntheory to the reader as it is beyond the scope of this article (enjoy\npuzzle solving instead of problem solving!).</p>\n<p>At this point I would emphasise that all of the above is why we should almost\ncertainly choose for FP in JS. Why choose complexity (or complectedness) when\nsimplicity is not only feasible but desirable? This is something FP can\noffer. What is more, there are theoretical or academic aspects to what I have\nmentioned but an enormous amount of practical usefulness too. JS libraries like\n<a href=\"https://lodash.com/\">lodash</a><sup>5</sup> and <a href=\"https://ramdajs.com/\">ramda</a> have\ndemonstrated this usefulness in many real-world applications.</p>\n<h2>Don’t write FP in JS</h2>\n<p>Consider the following reasons you should absolutely not write FP in JS. I\nwould like to explore two reasons, but in reality they are linked and are utter\ndefeaters for FP in JS today.</p>\n<h3>Tail call optimization (TCO)</h3>\n<p>The reality is that JS is not a language that is optimised for all things FP.\nFor instance, FP makes heavy use of calling functions inside of functions.\nSometimes as a mechanism of iteration known as recursion. In a large number of\ncases this is fine but in some cases this is totally not fine and will cause\nyour program to unexpectedly break.</p>\n<p>The reason your program will break is due to optimization. More specifically,\nlack of FP optimization in how JS is built. This is not something you can code\naround. It is woven into the very fabric of what JS <em>is</em> today. JavaScript is\nnot a compiled or a TCO language<sup>6</sup>. Even though much\nwork has been done in browsers and other runtimes to mitigate this, in the year\n2020 it is still possible to blow the call stack. What does this mean? Well, in\nsimple terms your program asks for more memory than is available to it because\nyour implementation does not follow the JS rules™. The stack depth is of finite\nsize, but the size is dependant upon the machine your JS runtime is running on.\nYou can not know in all cases how far you are permitted to go. If you choose to\nimplement this mechanism your code is instantly buggy. <strong>It will break</strong>. Okay, I\nhave overstated the case slightly, it will break under certain conditions.\nIf you know that the data over which you are recursing will <em>never</em> grow the\nstack beyond, say, 10 levels deep, you are in the clear. When you do not know\nhow deep the stack may get you are in treachorous waters<sup>7</sup>.</p>\n<h3>Immutability (or lack thereof)</h3>\n<p>Another, and quite pressing reason to not go whole-hog FP in JS is because many\nnative data structures are not immutable. Consider this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> myObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  obj<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span>myObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// { a: 42 }</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>For someone who writes code in a language optimized for FP this may be a shock,\nbut to many others this may not be. The fact is objects, arrays and functions\nare passed around as values which can be changed in an in-place way. This means\na change is visible to anyone with a reference to that value. This fact can\nlead to many issues in FP so to fix this we must explicity copy that specific\nvalue. Like so: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> myObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> myNewObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>obj<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span>myObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// { a: 1 }</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Problem solved! However, the problem is actually not sovled for many cases when\nwe have objects inside objects inside objects inside arrays. To preserve\nthat behaviour we would need to do something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> originalObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> b<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> c<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">{</span> d<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> e<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> copyThatChangedD <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>originalObject<span class=\"token punctuation\">,</span>\n  a<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>originalObject<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>originalObject<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">,</span>\n      c<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>originalObject<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>d<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>originalObject<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Only then will we have successfully copied all values, achieving an immutable\nfacade and ensuring that no other reference has been affected. There are many\nprogrammatic implementations that were made to solve this very problem. But\nconsider the case when we do not always know how deep our data structure may\nbe. We are back to the problem of optimization I mentioned before! Especially\nfor larger objects, we can quickly incur a large performance cost and risk\nblowing the stack again.</p>\n<p>There are many users of the web out there running on old Android devices or\nother low-memory environments which will not be able to handle the memory\nfootprint created by strictly following FP in JS.</p>\n<h2>Closing thoughts</h2>\n<p>There are almost certainly other cases of where FP in JS is a bad fit. My\nadvice is to be cautious when implementing FP in JS. Think carefully about the\nenvironment in which your code will run given the constraints in place. Use\nmutation to your advantage, it is a truly powerful tool and your only saving\ngrace for low(er)-memory devices accessing your website or sending data\nto your JS server.</p>\n<p>Finally, do not abandon FP in JS. It is a truly powerful tool that can help\ncreate a clean code base with a lower learning curve for many in the JS\ncommunity who are more familiar with patterns like redux.</p>\n<h3>Notes</h3>\n<ol>\n<li>Listed as one of the points\n<a href=\"https://clojure.org/about/rationale#_object_orientation_is_overrated\">here</a>.</li>\n<li>See <a href=\"https://youtu.be/AkYDsiRVqno?t=875\">this</a> section of a talk by Stefan\nTilkov.</li>\n<li>Today, at time of writing, I would argue pathologically extreme.</li>\n<li>See a library like <a href=\"https://github.com/gcanti/fp-ts\">fp-ts</a>.</li>\n<li>Please do not add this entire library as a dependency in new projects. There\nare many security vulnerabilities that come with it and much of it’s\nfunctionality has since been made available through JS natively.</li>\n<li>TypeScript is a <em>transpiler</em> not a <em>compiler</em> even though it may perform\ntasks that are similar to a compiler.</li>\n<li>I have run into this very issue using a library like <a href=\"https://github.com/immerjs/immer\">immer</a>.</li>\n</ol>","frontmatter":{"title":"(Don't) write FP in JS","date":"March 21, 2020"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"code","slug":"/code/fp-in-js/","previous":{"fields":{"slug":"/code/elastic-and-zdog/"},"frontmatter":{"title":"Elastic and Zdog"}},"next":{"fields":{"slug":"/code/errors/"},"frontmatter":{"title":"Errors"}}}}